## 객체의 구성 요소  

### 객체 = 속성(변수) + 기능(메서드) 
- 속성 - 크기, 길이, 높이 색상, 볼륨, 채널 등  
- 기능 - 켜기, 끄기, 볼륨 높이기, 볼륨 낮추기, 채널 변경하기 등  

`객체` - 모든 인스턴스를 대표하는 일반적 용어  
`인스턴스` - 특정 클래스로부터 생성된 객체  

`설계도`-------------------------＞ `제품`  
클래스를 인스턴스화 한 것이 객체(인스턴스)  

클래스가 왜 필요한가? - 객체를 생성하기 위해.  

객체가 왜 필요한가? - 객체를 사용하기 위해.  

객체를 사용한다는 것은? - 객체가 가진 속성과 기능을 사용하려고. (변수와 메서드) 

### 객체의 선언  

클래스명 변수명; // 참조변수 선언  

변수명 = new 클래스명(); // 클래스 객체 생성 수, 주소를 참조변수에 저장  

한 파일에 여러 클래스를 작성할 수 있음  
단, main 메서드가 들어가 있는 클래스가 파일 명으로 되어있어야 실행이 가능함.

예) Ex.java
```java
class Ex{ 
    public static void main(String arge[]){
Tv t; // Tv클래스 타입의 참조변수 t 선언
t = new Tv(); // Tv인스턴스 생성 수, Tv의 주소를 t에 저장
    }
}

class Tv {
    //Tv의 속성
    String color; // 색상
    boolean power; // 전원
    int channel; // 채널

    //Tv의 기능(메서드)
    void power() {power = !power;}
    void channelup() {++channel;}
    void channeldown() {--channel;}
}
```
## 객체 배열  
객체배열 == 참조변수 배열  

Tv tv1, tv2, tv3; → Tv[] tvArr = new Tv[3];  

Tv[] tvArr = new Tv[3]; // 길이가 3인 Tv타입의 참조변수 배열 생성  

// 객체를 생성해서 배열에 각 요소 저장  
tvArr[0] = new Tv();


## 선언 위치에 따른 객체 종류

```java
class Card{
    // 클래스 구간
    int iv;
    static int cv;

    void main (String[] args){
    // 메서드 구간
        int lv;
    }
}
```
`iv, cv`는 해당 클래스 내에서만 활성화  
`lv` (local variable) = 메서드 내에서만 사용  

---
`iv` (Instance Variable) = 클래스의 개별 속성에 사용  
`cv` (Class Variable) = 클래스의 공통 속성에 사용  

// <span style = "color:yellow">  따로 사용하는 이유 </span> :   
공통 속성을 하나 만들어서 그것만 사용하면, 불필요한 메모리를 사용하지 않을 수 있음.   
하나만 수정하면 모든 공통 속성이 수정되기 때문에 수정하기 편함.

```java
class Card {
    //인스턴스 변수
    String kind;
    int number;
    //클래스 변수
    static int width = 100;
    static int height = 250;
}


Card c1 = new Card();
c1.kind = "HEART";
c1.number = 5;

//c1.width = 200;
//c1.height = 300; == 권장하지 않음. iv로 오해할 수 있음.

Card.width = 200;
Card.height = 300; // == 앞에 클래스 이름을 붙임


Card c2 = new Card();
c2.kind = "CLOVER";
c2.number = 7;
// 위에서 너비, 높이를 변경했기 때문에 100,250이 아닌 200,300이 들어가게 됨.
// 
// (위에서 c1.width를 쓰던 Card.width를 쓰던 결과는 같음)
```

## 메서드  
- 문장들을 `작업단위`로 묶어놓은 것.  
(코드중복을 제거할 수 있음)  
- 클래스 안에 있어야 함.  
(함수는 클래스에 독립적)  
- 하나의 메서드는 하나의 기능만 하도록 작성.

![Alt text](../image/%EB%A9%94%EC%84%9C%EB%93%9C.JPG)  

#### 메서드 = 선언부 + 구현부  
    선언부 : 반환타입 메서드이름 (타입 변수명, 타입변수명, ...) 0개~n개  

---
    구현부 : 메서드 호출 시 수행될 코드  

메서드의 출력값은 0개~ 1개  
여러 개의 값을 출력하려면 `배열` 또는 `객체`를 사용하여 출력.  
반환할 것이 없을 때는 반환 타입에 `void`.  

지역변수 (lv) 는 `다른 메서드 내에 변수`와 <span style = "color:pink">같은</span> 이름을 사용해도 겹치지 않음.  
적용 범위가 <span style = "color:lightgreen">해당 메서드 영역</span>까지이기 때문.  

### 메서드의 호출   

    메서드이름 (값1, 값2, ...);
#### ex)
#### print99danAll();    // void print99danALl()을 호출  
#### int result = add(3,5);  // int add(int x, int y)를 호출하고, 결과를 result에 저장  
---
### return문, 반환값  

`메서드의 끝`에는 항상 return문이 존재해야 함  
(반환값이 없는 void 타입일 경우엔 없어도 됨)  

    if (a>b){
    return a;
    }
a<b 일 경우엔 return문이 없으므로 에러 발생  
### 호출 스택 (call stack)  
- 스택 : LIFO  

호출스택이란 스택에 호출하여 작업하는 공간

---
### 기본형 매개변수  
읽기만 가능. 수정 불가.  

### 참조형 매개변수  
읽기, 수정 가능.  
